/*
 * #%L
 * OME-XML C++ library for working with OME-XML metadata structures.
 * %%
 * Copyright © 2006 - 2016 Open Microscopy Environment:
 *   - Massachusetts Institute of Technology
 *   - National Institutes of Health
 *   - University of Dundee
 *   - Board of Regents of the University of Wisconsin-Madison
 *   - Glencoe Software, Inc.
 * %%
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of any organization.
 * #L%
 */

/*─────────────────────────────────────────────────────────────────────────────
 *
 * THIS IS AUTOMATICALLY GENERATED CODE.  DO NOT MODIFY.
 *
 *─────────────────────────────────────────────────────────────────────────────
 */

{% if fu.SOURCE_TYPE == "header" %}\
#ifndef ${fu.GUARD}
#define ${fu.GUARD}

#include <algorithm>
#include <list>
#include <stdexcept>
#include <string>
#include <vector>

#include <ome/common/log.h>

{% if klass.name == "AffineTransform" %}\
#include <ome/common/units/angle.h>

{% end class is AffineTransform %}\
#include <ome/common/xml/dom/Document.h>
#include <ome/common/xml/dom/Element.h>
#include <ome/common/xml/dom/Node.h>

#include <ome/xml/model/primitives/Quantity.h>

{% for include in klass.header_dependencies %}\
#include <${include}>
{% end for%}\
{% end header%}\
{% if fu.SOURCE_TYPE == "source" %}\
{% if klass.name == "AffineTransform" %}\
#include <cmath>
{% end class is AffineTransform %}\
#include <sstream>

{% if klass.hasPrimitiveBase %}\
#include <ome/common/base64.h>
{% end primitive base %}\
#include <ome/common/xml/String.h>

#include <ome/xml/Document.h>
#include <ome/xml/model/ModelException.h>
#include <ome/xml/model/Reference.h>
#include <ome/xml/model/detail/Parse.h>

#include <boost/format.hpp>

{% for include in klass.source_dependencies %}\
#include <${include}>
{% end for%}\

using boost::format;
{% end source%}\

namespace ome
{
  namespace xml
  {
    namespace model
    {

{% if fu.SOURCE_TYPE == "header" %}\
{% if len(klass.forward) %}\
      // Forward declarations.
{% end if %}\
{% for f in klass.forward %}\
      class ${f};
{% end for %}\

      /**
       * ${klass.name} model object.
       */
{% if klass.parentName is not None %}\
      class ${klass.name} : public ${klass.parentName}
{% end has parentName %}\
{% if klass.parentName is None %}\
      class ${klass.name}
{% end no parentName %}\
      {
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\

      /// Private implementation details of ${klass.name} model object.
      class ${klass.name}::Impl
      {
      public:
{% if len(klass.instanceVariables) > 0 %}\
{% for prop in klass.instanceVariables %}\
{% if prop[3] is not None %}\
        /// ${prop[3]}
{% end has comment %}\
{% if prop[0] is not None %}\
        ${prop[0]} ${prop[1]};
{% end has instance type %}\
{% end for %}\
{% end has instanceVariables %}\

        /// Default constructor.
{% if len(klass.instanceVariables) > 0 %}\
        Impl():
{% for prop in klass.instanceVariables %}\
{% if prop[0] is not None %}\
{% if prop == klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
          ${prop[1]}(${prop[2]})
{% end has default %}\
{% if prop[2] is None %}\
          ${prop[1]}()
{% end no default %}\
{% end last member %}\
{% if prop != klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
          ${prop[1]}(${prop[2]}),
{% end has default %}\
{% if prop[2] is None %}\
          ${prop[1]}(),
{% end no default %}\
{% end not last member %}\
{% end has instance type %}\
{% end for %}\
{% end has instanceVariables %}\
{% if len(klass.instanceVariables) == 0 %}\
        Impl()
{% end no instanceVariables %}\
         {
         }

{% if len(klass.instanceVariables) > 0 %}\
         /**
          * Copy constructor.
          *
          * @param copy the instance to copy.
          */
        Impl(const Impl& copy):
{% for prop in klass.instanceVariables %}\
{% if prop[0] is not None %}\
{% if prop == klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
          ${prop[1]}(copy.${prop[1]})
{% end has default %}\
{% if prop[2] is None %}\
          ${prop[1]}(copy.${prop[1]})
{% end no default %}\
{% end last member %}\
{% if prop != klass.instanceVariables[-1] %}\
{% if prop[2] is not None %}\
          ${prop[1]}(copy.${prop[1]}),
{% end has default %}\
{% if prop[2] is None %}\
          ${prop[1]}(copy.${prop[1]}),
{% end no default %}\
{% end not last member %}\
{% end has instance type %}\
{% end for %}\
{% end has instanceVariables %}\
{% if len(klass.instanceVariables) == 0 %}\
        /// Copy constructor.
        Impl(const Impl& /* copy */)
{% end no instanceVariables %}\
        {
        }
      };

      // ModelObject: ${klass.name}
      // Namespace:   ${klass.namespace}
      //
      // Parent:                    ${klass.parentName}
{% if klass.modelBaseType is not None %}\
      // InstanceVariableName:      ${klass.instanceVariableName}
      // ModelBaseType:             ${klass.modelBaseType}
{% end %}\
{% if klass.langBaseType is not None %}\
      // LangBaseType:              ${klass.langBaseType}
      // LangType:                  ${klass.langType}
      // LangTypeNS:                ${klass.langTypeNS}
{% end %}\
      //
      // Abstract:                  ${klass.isAbstract}
      // ParentAbstract:            ${klass.isParentAbstract}
      // Annotation:                ${klass.isAnnotation}
      // Annotated:                 ${klass.isAnnotated}
      // Described:                 ${klass.isDescribed}
      // Named:                     ${klass.isNamed}
      // Reference:                 ${klass.isReference}
      //
      // Properties:
{% for prop in klass.instanceVariables %}\
{% if prop[0] is not None %}\
      //   ${prop[1]}
      //     Instance type: ${prop[0]}
{% if prop[2] is not None %}\
      //     Default:       ${prop[2]}
{% end no default %}\
{% if prop[3] is not None %}\
      //     Comment:       ${prop[3]}
{% end no comment %}\
{% end has instance type %}\
{% end for %}\

{% end source %}\
{% if fu.SOURCE_TYPE == "header" %}\
      private:
        class Impl;
        /// Private implementation details.
        std::shared_ptr<Impl> impl;

      public:
        /// Default constructor.
        ${klass.name}();

{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${klass.name}::${klass.name}():
        ${lang.omexml_model_package}::OMEModelObject(),
{% if klass.parentName is not None %}\
        ${klass.parentName}(),
{% end has parent %}\
        impl(std::make_shared<Impl>())
      {
#ifdef OME_HAVE_BOOST_LOG
        logger.add_attribute("ClassName", logging::attributes::constant<std::string>("${klass.name}"));
#else // ! OME_HAVE_BOOST_LOG
        logger.className("${klass.name}");
#endif // OME_HAVE_BOOST_LOG
{% if klass.name == "AffineTransform" %}\
        // Set to identity
        setA00(1.0);
        setA01(0.0);
        setA02(0.0);
        setA10(0.0);
        setA11(1.0);
        setA12(0.0);
{% end class is AffineTransform %}\
      }

{% end source %}\
{% if klass.name == "AffineTransform" %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Construct an AffineTransform corresponding to
         * the given angle.
         *
         * @param theta the angle of rotation in radians
         */
        AffineTransform(ome::common::units::radian_quantity theta);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      AffineTransform::AffineTransform(ome::common::units::radian_quantity theta)
      {
        double v = ome::common::units::quantity_cast<double>(theta);
        setA02(0.0);
        setA12(0.0);
        setA00(cos(v));
        setA11(cos(v));
        setA01(sin(v));
        setA10(-1.0 * sin(v));
      }

{% end source %}\
{% end class is AffineTransform %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Copy constructor.
         *
         * @param copy the ${klass.name} to copy.
         */
        ${klass.name} (const ${klass.name}& copy);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${klass.name}::${klass.name} (const ${klass.name}& copy):
        ${lang.omexml_model_package}::OMEModelObject(),
{% if klass.parentName is not None %}\
        ${klass.parentName}(copy),
{% end has parent %}\
        impl(std::make_shared<Impl>(*copy.impl))
      {
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /// Destructor.
        virtual
        ~${klass.name} ();
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${klass.name}::~${klass.name} ()
      {
      }
{% end source %}\

{% if not klass.isAbstract %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Create a ${klass.name} model object from DOM element.
         *
         * @param element root of the XML DOM tree to from which to
         * construct the model object graph.
         * @param model handler for the OME model used to track
         * instances and references seen during the update.
         * @throws EnumerationException if there is an error
         * instantiating an enumeration during model object creation,
         * or ModelException if there are any consistency or validity
         * errors found during processing.
         *
         * @returns a new model object.
         */
        static std::shared_ptr<${klass.name}>
        create(const common::xml::dom::Element& element,
               ${lang.omexml_model_package}::OMEModel& model);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      std::shared_ptr<${klass.name}>
      ${klass.name}::create(const common::xml::dom::Element& element,
                              ${lang.omexml_model_package}::OMEModel& model)
      {
        std::shared_ptr<${klass.name}> newinstance(std::make_shared<${klass.name}>());
        newinstance->update(element, model);
        return newinstance;
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        // Documented in superclass.
        const std::string&
        elementName() const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::string&
      ${klass.name}::elementName() const
      {
        static const std::string type("${klass.name}");
        return type;
      }
{% end source %}\

{% end not Abstract %}\
{% if fu.SOURCE_TYPE == "header" %}\
        // Documented in superclass.
        bool
        validElementName(const std::string& name) const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::validElementName(const std::string& /* name */) const
      {
        return true;
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /// @cond SKIP
        ${klass.name}&
        operator= (const ${klass.name}&) = delete;
        /// @endcond SKIP

{% end header %}\
{% if len(customContent) > 0 %}\
        // -- Custom content from ${klass.name} specific template --

${customContent}\
{% end custom content %}\
{% if fu.SOURCE_TYPE == "header" %}\
        // -- OMEModelObject API methods --

        /// @copydoc ${lang.omexml_model_package}::OMEModelObject::update
        virtual void
        update(const common::xml::dom::Element&  element,
               ${lang.omexml_model_package}::OMEModel& model);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::update(const common::xml::dom::Element&  element,
                            ${lang.omexml_model_package}::OMEModel& model)
      {
        ${klass.parentName}::update(element, model);

{% if klass.langBaseType is not None %}\
        {
          // Element's text data
          std::string text(element.getTextContent());
{% if klass.langBaseType != 'std::string' %}\
          if (!text.empty())
            {
              set_value(text
                        *this, &${klass.name}::setValue,
                        "${klass.name}", "value");
            }
{% end %}\
{% if klass.langBaseType == 'std::string' %}\
          this->impl->value = text;
{% end %}\
        }
{% end %}\
        const std::string tagName(element.getTagName());
        if (!validElementName(tagName))
          {
            BOOST_LOG_SEV(logger, ome::logging::trivial::warning)
              << tagName << " is an invalid element name for ${klass.name}";
          }
{% for prop in klass.properties.values() %}\
{% choose %}\
{% when prop.name in customUpdatePropertyContent %}\
{% if debug %}\
        // -- BEGIN custom content from ${prop.name} property template --
{% end debug %}\
${customUpdatePropertyContent[prop.name]}
{% if debug %}\
        // -- END custom content from ${prop.name} property template --
{% end debug %}\
{% end %}\
{% when prop.hasBaseAttribute %}\
        // Element's text data
        std::string value_textContent(element.getTextContent());
        if (value_textContent.length() > 0)
          {
{% if prop.type == 'base64Binary' %}\
            std::vector<uint8_t> rawBytes;
            ome::common::base64_decode(value_textContent, std::back_inserter(rawBytes));
            set${prop.methodName}(rawBytes);
{% end if prop.type %}\
{% if not prop.type == 'base64Binary' %}\
            set${prop.methodName}(value_textContent);
{% end if not prop.type %}\
          }
{% end when %}\
{% when prop.isReference %}\
        // Element reference ${prop.name}
        std::vector<common::xml::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        for (auto& elem : ${prop.name}_nodeList)
          {
            std::shared_ptr<${prop.name}> rcptr(std::make_shared<${prop.name}>());
            rcptr->setID(elem.getAttribute("ID"));
            std::shared_ptr<Reference> rptr(std::static_pointer_cast<Reference>(rcptr));
            std::shared_ptr<${lang.omexml_model_package}::OMEModelObject> optr(std::static_pointer_cast<${lang.omexml_model_package}::OMEModelObject>(shared_from_this()));
            model.addReference(optr, rptr);
          }
{% end %}\
{% when prop.isBackReference %}\
{% if debug %}\
        // *** IGNORING *** Skipped back reference ${prop.name}
{% end debug %}\
{% end %}\
{% when prop.isAttribute and prop.name == "ID" %}\
        if (!element.hasAttribute("ID") && getID().empty())
          {
            throw ModelException("${klass.name} missing required ID property");
          }
        if (element.hasAttribute("ID"))
           {
             // ID property
{% if klass.langBaseType != 'std::string' %}\
             set_value(element.getAttribute("${prop.name}"),
                       *this, &${klass.name}::set${prop.methodName},
                       "${klass.name}", "${prop.name}");
{% end %}\
{% if klass.langBaseType == 'std::string' %}\
             set${prop.methodName}(element.getAttribute("${prop.name}"));
{% end if %}\
             // Adding this model object to the model handler
             std::shared_ptr<${lang.omexml_model_package}::OMEModelObject> thisptr(std::dynamic_pointer_cast<  ${lang.omexml_model_package}::OMEModelObject>(shared_from_this()));
             model.addModelObject(getID(), thisptr);
           }
{% end when prop.isAttribute and prop.name == "ID" %}\
{% when prop.isAttribute and prop.isUnitsEnumeration %}\
{% if debug %}\
           // *** Ignoring *** units enumeration ${prop.name}
{% end debug %}\
{% end when prop.isAttribute and prop.isUnitsEnumeration %}\
{% when prop.isAttribute and not prop.isUnitsEnumeration %}\
        if (element.hasAttribute("${prop.name}"))
          {
{% choose %}\
{% when prop.isEnumeration and not prop.isUnitsEnumeration %}\
            // Attribute property which is an enumeration ${prop.name}
{% if prop.minOccurs == 0 %}\
            std::string text(element.getAttribute("${prop.name}"));
            ${prop.instanceVariableType} nattr(std::make_shared<${prop.langTypeNS}>(text));
            set${prop.methodName}(nattr);
{% end prop.minOccurs == 0 %}\
{% if prop.minOccurs > 0 %}\
            set${prop.methodName}(${prop.langTypeNS}(element.getAttribute("${prop.name}")));
{% end prop.minOccurs > 0 %}\
{% end when prop.isEnumeration and not prop.isUnitsEnumeration %}\
{% when prop.hasUnitsCompanion %}\
            // Attribute property ${prop.name} with unit companion ${prop.unitsCompanion.name}
            std::string unitSymbol("${prop.unitsDefault}");
            if (element.hasAttribute("${prop.unitsCompanion.name}"))
              {
                unitSymbol = element.getAttribute("${prop.unitsCompanion.name}");
                if(unitSymbol.empty())
                  unitSymbol = "${prop.unitsDefault}";
              }

            set_quantity(element.getAttribute("${prop.name}"), unitSymbol,
                         *this, &${klass.name}::set${prop.methodName},
                         "${klass.name}", "${prop.name}");
{% end when prop.hasUnitsCompanion %}\
{% when not prop.isEnumeration %}\
            // Attribute property ${prop.name}
            {
{% if prop.instanceVariableType != 'std::string' %}\
              set_value(element.getAttribute("${prop.name}"),
                        *this, &${klass.name}::set${prop.methodName},
                        "${klass.name}", "${prop.name}");
{% end %}\
{% if prop.instanceVariableType == 'std::string' %}\
              set${prop.methodName}(element.getAttribute("${prop.name}"));
{% end %}\
            }
{% end choose %}\
{% end %}\
          }
{% end %}\
{% when prop.maxOccurs == 1 and (not klass.isAbstract or not prop.isAttribute) %}\
        std::vector<common::xml::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        if (${prop.name}_nodeList.size() > 1)
          {
            format fmt("${prop.name} node list size %1% != 1");
            fmt % ${prop.name}_nodeList.size();
            throw ModelException(fmt.str());
          }
        else if (${prop.name}_nodeList.size() != 0)
          {
{% if prop.isComplex() %}\
            // Element property ${prop.name} which is complex (has sub-elements)
{% if prop.minOccurs == 0 or (not lang.hasPrimitiveType(prop.langType) and not prop.isEnumeration) %}\
            common::xml::dom::Element elem(${prop.name}_nodeList.at(0));
            // While std::make_shared<> works, here,
            // boost::make_shared<> does not, so use new directly.
{% if prop.langTypeNS != 'ome::xml::model::primitives::OrderedMultimap' %}\
            ${prop.instanceVariableType} p(${prop.langTypeNS}::create(elem, model));
{% end %}\
{% if prop.langTypeNS == 'ome::xml::model::primitives::OrderedMultimap' %}\
            ${prop.instanceVariableType} p(std::make_shared<${prop.langTypeNS}>());

            std::vector<common::xml::dom::Element> children(getChildrenByTagName(elem, "M"));
            for (auto& child : children)
              {
                if (child.hasAttribute("K"))
                  p->get<0>().insert(p->end(),
                                     ome::xml::model::primitives::OrderedMultimap::value_type(child.getAttribute("K"),
                                                                                              child.getTextContent()));
                else
                  {
                    BOOST_LOG_SEV(logger, ome::logging::trivial::warning)
                      << "MapAnnotation entry M does not contain key attribute K";
                  }
              }
{% end %}\
{% end %}\
{% if prop.minOccurs > 0 and (lang.hasPrimitiveType(prop.langType) or prop.isEnumeration) %}\
            common::xml::dom::Element elem(${prop.name}_nodeList.at(0));
{% if prop.langTypeNS != 'ome::xml::model::primitives::OrderedMultimap' %}\
            ${prop.langTypeNS} p(elem, model);
{% end %}\
{% if prop.langTypeNS == 'ome::xml::model::primitives::OrderedMultimap' %}\
            ${prop.instanceVariableType} p;

            std::vector<common::xml::dom::Element> children(getChildrenByTagName(elem, "M"));
            for (std::vector<common::xml::dom::Element>::iterator child = children.begin();
                 child != children.end();
                 ++child)
              {
                if (child->hasAttribute("K"))
                  p.get<0>().insert(p.end(),
                                    ome::xml::model::primitives::OrderedMultimap::value_type(child->getAttribute("K"),
                                                                                             child->getTextContent()));
                else
                  {
                    BOOST_LOG_SEV(logger, ome::logging::trivial::warning)
                      << "MapAnnotation entry M does not contain key attribute K";
                  }
              }
{% end %}\
{% end %}\
            set${prop.methodName}(p);
{% end %}\
{% if not prop.isComplex() %}\
            // Element property ${prop.name} which is not complex (has no
            // sub-elements)
            std::string text(${prop.name}_nodeList.at(0).getTextContent());
{% if prop.minOccurs == 0 %}\
            ${prop.instanceVariableType} ns(std::make_shared<${prop.langTypeNS}>(text));
            set${prop.methodName}(ns);
{% end %}\
{% if prop.minOccurs > 0 %}\
{% if prop.langTypeNS != 'std::string' %}\
             set_value(text,
                       *this, &${klass.name}::set${prop.methodName},
                       "${klass.name}", "${prop.name}");
{% end %}\
{% if prop.langTypeNS == 'std::string' %}\
            set${prop.methodName}(text);
{% end %}\
{% end %}\
{% end %}\
          }
{% end %}\
{% when prop.maxOccurs > 1 and prop.isComplex() and not klass.isAbstract %}\
{% if prop.isAbstract %}\
{% if prop.isAbstractSubstitution %}\
      // Element property ${prop.name} which is complex (has
      // sub-elements) and occurs more than once. The element's model
      // object type is also abstract so we need to have a handler for
      // each "subclass".
{% for subClass in prop.concreteClasses %}\
      std::vector<common::xml::dom::Element> ${subClass}_nodeList(getChildrenByTagName(element, "${subClass}"));
      for (auto& elem : ${subClass}_nodeList)
        {
          std::shared_ptr<${prop.methodName}> object(${subClass}::create(elem, model));
          add${prop.methodName}(object);
        }
{% end %}\
{% end %}\
{% if not prop.isAbstractSubstitution %}\
        // Element property ${prop.name} which is complex (has
        // sub-elements) and occurs more than once. The element's model
        // object type is also abstract so we need to have a handler for
        // each "subclass".
        std::vector<common::xml::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        for (const auto& elem : ${prop.name}_nodeList)
          {
{% for inner_prop in model.getObjectByName(prop.name).properties.values() %}\
{% if not inner_prop.isAttribute and inner_prop.isComplex() and not inner_prop.isReference and inner_prop.isChoice %}\
            std::vector<common::xml::dom::Element> ${inner_prop.name}_nodeList(getChildrenByTagName(elem, "${inner_prop.name}"));
            for (auto& inner_elem : ${inner_prop.name}_nodeList)
              {
                // While std::make_shared<> works, here,
                // boost::make_shared<> does not, so use new
                // directly.
                std::shared_ptr<${prop.methodName}> object(${inner_prop.langTypeNS}::create(elem, model));
                object->update(inner_elem, model);
                add${prop.methodName}(object);
              }
{% end %}\
{% end %}\
          }
{% end %}\
{% end %}\
{% if not prop.isAbstract %}\
        // Element property ${prop.name} which is complex (has
        // sub-elements) and occurs more than once
        std::vector<common::xml::dom::Element> ${prop.name}_nodeList(getChildrenByTagName(element, "${prop.name}"));
        for (auto& elem : ${prop.name}_nodeList)
          {
            // While std::make_shared<> works, here,
            // boost::make_shared<> does not, so use new directly.
            std::shared_ptr<${prop.methodName}> object(${prop.langTypeNS}::create(elem, model));
            add${prop.methodName}(object);
          }
{% end %}\
{% end %}\
{% when prop.maxOccurs > 1 %}\
        // Element property ${prop.name} which is not complex (has no
        // sub-elements) which occurs more than once
        std::vector<common::xml::dom::Element> ${prop.name}_nodeList(getChildrenByTagName("${prop.name}"));
        for (auto& elem : ${prop.name}_nodeList)
          {
            std::string text(elem.getTextContent());
            std::shared_ptr<${prop.methodName}> object(${prop.langTypeNS}::create(text, model));
            add${prop.methodName}(object);
          }
{% end %}\
{% otherwise %}\
{% if debug %}\
        // *** WARNING *** Unhandled or skipped property ${prop.name}
{% end debug %}\
{% end %}\
{% end %}\
{% end %}\
      }

{% end source %}\
{% if fu.SOURCE_TYPE == "header" %}\

      public:
        // -- ${klass.name} API methods --

        /// @copydoc ${lang.omexml_model_package}::OMEModelObject::link
        bool
        link (std::shared_ptr<Reference>& reference,
              std::shared_ptr<${lang.omexml_model_package}::OMEModelObject>& object);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::link (std::shared_ptr<Reference>& reference,
                           std::shared_ptr<${lang.omexml_model_package}::OMEModelObject>& object)
      {
{% for prop in klass.properties.values() %}\
{% if prop.isReference %}\
        if (std::dynamic_pointer_cast<${prop.name}>(reference))
          {
            /// @todo This bit is silly; why do we have two dynamic_casts here.
            std::shared_ptr<${prop.langTypeNS}> o_casted = std::dynamic_pointer_cast<${prop.langTypeNS}>(object);
            if (o_casted)
              {
{% if not fu.link_overridden(prop.name, klass.name) %}\
{% if not fu.backReference_overridden(prop.name, klass.name) %}\
                o_casted->link${klass.type}(std::dynamic_pointer_cast<${klass.type}>(shared_from_this()));
{% end %}\
{% if fu.backReference_overridden(prop.name, klass.name) %}\
                o_casted->link${klass.name}${prop.methodName}(std::dynamic_pointer_cast<${klass.type}>(shared_from_this()));
{% end %}\
{% end %}\
{% if prop.maxOccurs > 1 %}\
{% if not prop.isReference and not prop.isBackReference %}\
                if (contains(this->impl->${prop.instanceVariableName}, o_casted))
                  {
                    this->impl->${prop.instanceVariableName}.push_back(o_casted);
                  }
{% end %}\
{% if prop.isReference or prop.isBackReference %}\
                typedef OMEModelObject::indexed_container<${prop.langTypeNS}, std::weak_ptr>::type::nth_index<1>::type container_set_type;
                container_set_type::iterator it(this->impl->${prop.instanceVariableName}.get<1>().find(o_casted));
                if (it == this->impl->${prop.instanceVariableName}.get<1>().end())
                  {
                    this->impl->${prop.instanceVariableName}.push_back(o_casted);
                  }
{% end %}\
{% end %}\
{% if prop.maxOccurs == 1 %}\
                this->impl->${prop.instanceVariableName} = o_casted;
{% end %}\
                return true;
              }
          }
{% end %}\
{% end %}\
        return ${klass.parentName}::link(reference, object);
      }
{% end source %}\
{% if klass.langBaseType is not None %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get element value.
         *
         * @returns the ${klass.langBaseType} value.
         */
        const ${klass.langBaseType}&
        getValue () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const ${klass.langBaseType}&
      ${klass.name}::getValue () const
      {
        return this->impl->value;
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set element value.
         *
         * @param value the ${klass.langBaseType} value.
         */
        void
        setValue (const ${klass.langBaseType}& value);
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::setValue (const ${klass.langBaseType}& value)
      {
        this->impl->value = value;
      }
{% end source %}\
{% end not object %}\

{% for prop in klass.properties.values() %}\
{% if not prop.isUnitsEnumeration %}\
{% choose %}\
{% when (prop.isReference or prop.isBackReference) and prop.maxOccurs > 1 %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get size of linked ${prop.methodName} list.
         *
         * @returns the size of the list.
         */
        ${prop.instanceVariableType}::size_type
        sizeOfLinked${prop.methodName}List () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Reference which occurs more than once
      ${prop.instanceVariableType}::size_type
      ${klass.name}::sizeOfLinked${prop.methodName}List () const
      {
        return this->impl->${prop.instanceVariableName}.size();
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the linked ${prop.methodName} list.
         *
         * @returns a reference to the list.
         */
        ${prop.instanceVariableType}
        getLinked${prop.methodName}List () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${prop.instanceVariableType}
      ${klass.name}::getLinked${prop.methodName}List () const
      {
        return this->impl->${prop.instanceVariableName};
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get linked ${prop.methodName}.
         *
         * @param index the index number of the ${prop.methodName}.
         * @returns a weak pointer to the ${prop.methodName}.
         * @throws std::out_of_range if the index is invalid.
         */
        const std::weak_ptr<${prop.langTypeNS}>&
        getLinked${prop.methodName} (${prop.instanceVariableType}::size_type index) const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::weak_ptr<${prop.langTypeNS}>&
      ${klass.name}::getLinked${prop.methodName} (${prop.instanceVariableType}::size_type index) const
      {
        return this->impl->${prop.instanceVariableName}.at(index);
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set linked ${prop.methodName}.
         *
         * @note The index must be valid.
         *
         * @param index the index number of the ${prop.methodName}.
         * @param ${prop.argumentName} the ${prop.methodName} to set.
         * @returns a weak pointer to the ${prop.methodName}.
         * @throws std::out_of_range if the index is invalid.
         */
        const std::weak_ptr<${prop.langTypeNS}>&
        setLinked${prop.methodName} (${prop.instanceVariableType}::size_type index,
                                     const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::weak_ptr<${prop.langTypeNS}>&
      ${klass.name}::setLinked${prop.methodName}(${prop.instanceVariableType}::size_type index,
                                                 const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
{% if not prop.isReference and not prop.isBackReference %}\
        return this->impl->${prop.instanceVariableName}.at(index) = ${prop.argumentName};
{% end %}\
{% if prop.isReference or prop.isBackReference %}\
        ${prop.instanceVariableType}::iterator it(this->impl->${prop.instanceVariableName}.iterator_to(this->impl->${prop.instanceVariableName}.at(index)));
        const std::weak_ptr<${prop.langTypeNS}> wp(${prop.argumentName});
        this->impl->${prop.instanceVariableName}.replace(it, wp);
        return *it;
{% end %}\
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Link ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to link.
         * @returns @c true if the object was added to the internal
         * ${prop.instanceVariableName} list, otherwise @c false.
         *
         * @todo Why have a return value here; what is it used for?
         * Is this an artifact of the Java API?
         */
        bool
        link${prop.methodName} (const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::link${prop.methodName} (const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
{% if not prop.isBackReference and not fu.link_overridden(prop.name, klass.name) %}\
{% if not fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->link${klass.type}(std::dynamic_pointer_cast<${klass.name}>(shared_from_this()));
{% end %}\
{% if fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->link${klass.name}${prop.methodName}(std::dynamic_pointer_cast<${klass.name}>(shared_from_this()));
{% end %}\
{% end %}\
{% if not prop.isReference and not prop.isBackReference %}\
        if (!contains(this->impl->${prop.instanceVariableName}, ${prop.argumentName}))
          {
            this->impl->${prop.instanceVariableName}.push_back(${prop.argumentName});
            return true;
          }
{% end %}\
{% if prop.isReference or prop.isBackReference %}\
        typedef OMEModelObject::indexed_container<${prop.langTypeNS}, std::weak_ptr>::type::nth_index<1>::type container_set_type;
        container_set_type::iterator it(this->impl->${prop.instanceVariableName}.get<1>().find(${prop.argumentName}));
        if (it == this->impl->${prop.instanceVariableName}.get<1>().end())
          {
            std::pair<OMEModelObject::indexed_container<${prop.langTypeNS}, std::weak_ptr>::type::iterator, bool> res(this->impl->${prop.instanceVariableName}.push_back(std::weak_ptr<${prop.langTypeNS}>(${prop.argumentName})));
            return res.second;
          }
{% end %}\
        return false;
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Unlink ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to unlink.
         *
         * @returns @c true if the ${prop.methodName} was unlinked, otherwise
         * @c false if the ${prop.methodName} was not linked and could hence not be
         * unlinked.
         *
         * @todo Does the return value serve any useful purpose?  Is
         * this also inherited Java API?
         * @todo Doesn't the removal break the indexing?
         * @todo Does the removal deal with multiple instances; we
         * aren't preventing duplicates on insertion.
         */
        bool
        unlink${prop.methodName} (const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      bool
      ${klass.name}::unlink${prop.methodName} (const std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
{% if not prop.isBackReference and not fu.link_overridden(prop.name, klass.name) %}\
{% if not fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->unlink${klass.type}(std::dynamic_pointer_cast<${klass.name}>(shared_from_this()));
{% end %}\
{% if fu.backReference_overridden(prop.name, klass.name) %}\
        ${prop.argumentName}->unlink${klass.name}${prop.methodName}(std::dynamic_pointer_cast<${klass.name}>(shared_from_this()));
{% end %}\
{% end %}\
        bool found = false;
        ${prop.instanceVariableType}::iterator i =
          std::find_if(this->impl->${prop.instanceVariableName}.begin(),
                       this->impl->${prop.instanceVariableName}.end(),
                       compare_element<${prop.langTypeNS}>(${prop.argumentName}));
        if (i != this->impl->${prop.instanceVariableName}.end())
          {
            found = true;
            this->impl->${prop.instanceVariableName}.erase(i);
          }
        return found;
      }
{% end source %}\

{% end %}\
{% when prop.isReference %}\
{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get linked ${prop.methodName}.
         *
         * @returns the linked ${prop.methodName}.  The pointer may be
         * null.
         */
        ${prop.retType[qualifier]}
        getLinked${prop.methodName} ()${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Reference
      ${prop.retType[qualifier]}
      ${klass.name}::getLinked${prop.methodName} ()${qualifier}
      {
        return this->impl->${prop.instanceVariableName};
      }
{% end source %}\

{% end qualifier %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Link ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to link.
         */
        void
        link${prop.methodName} (std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::link${prop.methodName} (std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
        this->impl->${prop.instanceVariableName} = ${prop.argumentName};
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Unlink ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to unlink.
         *
         * @todo This method is fairly pointless since it's equivalent
         * to linking a null pointer.  It could call @c link(0)
         * internally.
         */
        void
        unlink${prop.methodName} (std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::unlink${prop.methodName} (std::shared_ptr<${prop.langTypeNS}>& ${prop.argumentName})
      {
        if (std::shared_ptr<${prop.langTypeNS}>(this->impl->${prop.instanceVariableName}) == ${prop.argumentName})
          {
            this->impl->${prop.instanceVariableName} = std::shared_ptr<${prop.langTypeNS}>();
          }
      }
{% end source %}\

{% end %}\
{% when prop.maxOccurs == 1 and (not klass.isAbstract or prop.isAttribute or not prop.isComplex() or not prop.isChoice) %}\
{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the ${prop.methodName} property.
         *
         * @returns the ${prop.methodName} property.
         */
        ${prop.retType[qualifier]}
        get${prop.methodName} ()${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Property
      ${prop.retType[qualifier]}
      ${klass.name}::get${prop.methodName} ()${qualifier}
      {
        return this->impl->${prop.instanceVariableName};
      }
{% end source %}\

{% end qualifier %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set the ${prop.methodName} property.
         *
         * @param ${prop.argumentName} the value to set.
         */
        void
        set${prop.methodName} (${prop.argType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Property
      void
      ${klass.name}::set${prop.methodName} (${prop.argType} ${prop.argumentName})
      {
        this->impl->${prop.instanceVariableName} = ${prop.argumentName};
      }
{% end source %}\

{% end %}\
{% when prop.maxOccurs > 1 and not klass.isAbstract %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get size of linked ${prop.methodName} list.
         *
         * @returns the size of the list.
         */
        ${prop.instanceVariableType}::size_type
        sizeOf${prop.methodName}List () const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      // Property which occurs more than once
      ${prop.instanceVariableType}::size_type
      ${klass.name}::sizeOf${prop.methodName}List () const
      {
        return this->impl->${prop.instanceVariableName}.size();
      }
{% end source %}\

{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the ${prop.methodName} list.
         *
         * @returns a reference to the list.
         *
         */
        ${prop.retType[qualifier]}&
        get${prop.methodName}List ()${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${prop.retType[qualifier]}&
      ${klass.name}::get${prop.methodName}List ()${qualifier}
      {
        return this->impl->${prop.instanceVariableName};
      }
{% end source %}\

{% end qualifier %}\
{% for qualifier in prop.retType.keys() %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get ${prop.methodName}.
         *
         * @param index the index number of the ${prop.methodName}.
         * @returns the ${prop.methodName}.
         * @throws std::out_of_range if the index is invalid.
         */
        ${prop.elementRetType[qualifier]}
        get${prop.methodName} (${prop.instanceVariableType}::size_type index)${qualifier};
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      ${prop.elementRetType[qualifier]}
      ${klass.name}::get${prop.methodName} (${prop.instanceVariableType}::size_type index)${qualifier}
      {
        return this->impl->${prop.instanceVariableName}.at(index);
      }
{% end source %}\

{% end qualifier %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Set ${prop.methodName}.
         *
         * @param index the index number of the ${prop.methodName}.
         * @param ${prop.argumentName} the ${prop.methodName} to set.
         * @throws std::out_of_range if the index is invalid.
         */
        void
        set${prop.methodName} (${prop.instanceVariableType}::size_type index,
                               ${prop.elementArgType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::set${prop.methodName} (${prop.instanceVariableType}::size_type index,
                                            ${prop.elementArgType} ${prop.argumentName})
      {
{% if klass.type != 'OME' %}\
        std::weak_ptr<${klass.type}> self(std::dynamic_pointer_cast<${klass.type}>(shared_from_this()));
        ${prop.argumentName}->set${klass.type}(self);
{% end %}\
{% if not prop.isReference and not prop.isBackReference %}\
        this->impl->${prop.instanceVariableName}.at(index) = ${prop.argumentName};
{% end %}\
{% if prop.isReference or prop.isBackReference %}\
        ${prop.instanceVariableType}::iterator it(this->impl->${prop.instanceVariableName}.iterator_to(this->impl->${prop.instanceVariableName}.at(index)));
        this->impl->${prop.instanceVariableName}.replace(it, ${prop.argumentName});
{% end %}\
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Add ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to add.
         *
         * @todo Return list position?
         * @todo Detect and handle duplicates?
         */
        void
        add${prop.methodName} (${prop.elementArgType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::add${prop.methodName} (${prop.elementArgType} ${prop.argumentName})
      {
{% if klass.type != 'OME' %}\
        std::weak_ptr<${klass.type}> self(std::dynamic_pointer_cast<${klass.type}>(shared_from_this()));
        ${prop.argumentName}->set${klass.type}(self);
{% end %}\
        this->impl->${prop.instanceVariableName}.push_back(${prop.argumentName});
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Remove ${prop.methodName}.
         *
         * @param ${prop.argumentName} the ${prop.methodName} to remove.
         *
         * @todo Doesn't the removal break the indexing?
         * @todo Does the removal deal with multiple instances; we
         * aren't preventing duplicates on insertion.
         */
        void
        remove${prop.methodName} (${prop.elementArgType} ${prop.argumentName});
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::remove${prop.methodName} (${prop.elementArgType} ${prop.argumentName})
      {
        ${prop.instanceVariableType}::iterator i = std::find_if(this->impl->${prop.instanceVariableName}.begin(),
                                                                this->impl->${prop.instanceVariableName}.end(),
                                                                compare_element<${prop.langTypeNS}>(${prop.argumentName}));
        if (i != this->impl->${prop.instanceVariableName}.end())
          this->impl->${prop.instanceVariableName}.erase(i);
      }
{% end source %}\

{% end %}\
{% otherwise %}\
{% if debug %}\
        // *** WARNING *** Unhandled or skipped property ${prop.name}
{% end debug %}\
{% end %}\
{% end %}\
{% end not prop.isUnitsEnumeration %}\
{% end for %}\
{% if klass.isConcreteSubstitution %}\
{% if fu.SOURCE_TYPE == "header" %}\
        const std::string&
        get${klass.parentName}Type() const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::string&
      ${klass.name}::get${klass.parentName}Type() const
      {
        static const std::string type("${klass.name}");
        return type;
      }
{% end source %}\

{% end  %}\
{% if klass.isAbstractSubstitution %}\
{% if fu.SOURCE_TYPE == "header" %}\
        /**
         * Get the ${klass.name} type.
         *
         * @returns the concrete type of the ${klass.name}.
         */
        virtual const std::string&
        get${klass.name}Type() const = 0;
{% end header %}\

{% end %}\
{% if fu.SOURCE_TYPE == "header" %}\
      protected:
        // Documented in base class.
        virtual void
        asXMLElementInternal (common::xml::dom::Document& document,
                              common::xml::dom::Element&  element) const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      void
      ${klass.name}::asXMLElementInternal (common::xml::dom::Document& document,
                                           common::xml::dom::Element&  element) const
      {
        // Create XML block for ${klass.name}

{% if klass.name == "OME" %}\
        static const std::string XSI_NAMESPACE("http://www.w3.org/2001/XMLSchema-instance");
        element.setAttribute("xmlns:xsi", XSI_NAMESPACE);
        element.setAttribute("xsi:schemaLocation", getXMLNamespace() + " " + getXMLNamespace() + "/ome.xsd");
{% end %}\
        if (!element)
          {
            common::xml::dom::Element newElement = document.createElementNS(getXMLNamespace(), "${klass.name}");
            element = newElement;
          }

{% if klass.langBaseType is not None %}\
        // Element's text data
//            if (!this->impl->value.empty()) {
{% if klass.langBaseType != 'std::string' %}\
        {
          std::ostringstream os;
          os.imbue(std::locale::classic());
{% if prop.langTypeNS != 'bool' %}\
          os << this->impl->value;
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
          os << std::boolalpha << this->impl->value;
{% end %}\
          element.setTextContent(os.str());
        }
{% end %}\
{% if klass.langBaseType == 'std::string' %}\
        element.setTextContent(this->impl->value);
{% end %}\
{% end %}\
        // Ensure any base annotations add their Elements first
        ${klass.parentName}::asXMLElementInternal(document, element);

{% for prop in klass.properties.values() %}\
{% if not prop.isUnitsEnumeration %}\
{% choose %}\
{% when prop.name in customAsXMLElementPropertyContent %}\
{% if debug %}\
        // -- BEGIN custom content from ${prop.name} property template --
{% end debug %}\
${customAsXMLElementPropertyContent[prop.name]}
{% if debug %}\
        // -- END custom content from ${prop.name} property template --
{% end debug %}\
{% end when %}\
{% when prop.hasBaseAttribute %}\
        // Element's text data
{% if not prop.type == 'base64Binary' %}\
        ${klass.name}_element.setTextContent(this->impl->${prop.instanceVariableName});
{% end if not prop.type %}\
{% if prop.type == 'base64Binary' %}\
        std::string encodedString = ome::common::base64_encode(this->impl->${prop.instanceVariableName}.begin(),
                                                               this->impl->${prop.instanceVariableName}.end(),
                                                                 0);
        element.setTextContent(encodedString);
{% end if prop.type %}\
{% end when %}\
{% when prop.isReference and prop.maxOccurs > 1 %}\
        {
          // Reference property ${prop.name} which occurs more than once
          for (auto& i : this->impl->${prop.instanceVariableName})
            {
              // Note that this doesn't strictly need to be a
              // shared_ptr, but keep compatible with the rest of
              // the API to allow consistency for future
              // refactoring.
              std::shared_ptr<${prop.name}> o(std::make_shared<${prop.name}>());
              std::shared_ptr<${prop.langTypeNS}> is(i.lock());
              if (is)
                {
                  o->setID(is->getID());
{% if prop.isAbstractSubstitution %}\
                  common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), o->get${prop.name}Type()));
{% end if %}\
{% if not prop.isAbstractSubstitution %}\
                  common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), "${prop.name}"));
{% end if %}\
                  o->asXMLElement(document, child);
                  element.appendChild(child);
                }
            }
        }
{% end %}\
{% when prop.isReference %}\
        {
          // Reference property ${prop.name}
          // Note that this doesn't strictly need to be a
          // shared_ptr, but keep compatible with the rest of the
          // API to allow consistency for future refactoring.
          std::shared_ptr<${prop.name}> o(std::make_shared<${prop.name}>());
          std::shared_ptr<${prop.langTypeNS}> sv(this->impl->${prop.instanceVariableName}.lock());
          if (sv)
            {
              o->setID(sv->getID());
{% if prop.isAbstractSubstitution %}\
              common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), o->get${prop.name}Type()));
{% end if %}\
{% if not prop.isAbstractSubstitution %}\
              common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), "${prop.name}"));
{% end if %}\
              o->asXMLElement(document, child);
              element.appendChild(child);
            }
        }
{% end %}\
{% when prop.isBackReference %}\
{% if debug %}\
        // *** IGNORING *** Skipped back reference ${prop.name}
{% end debug %}\
{% end %}\
{% when prop.hasUnitsCompanion and prop.isAttribute and prop.maxOccurs == 1%}\
{% if prop.minOccurs == 1 %}\
        {
          // Attribute property ${prop.name} with units companion ${prop.unitsCompanion.name}
          std::ostringstream os;
          os.imbue(std::locale::classic());
          os << this->impl->${prop.instanceVariableName}.getValue();
          element.setAttribute("${prop.name}", os.str());
          element.setAttribute("${prop.unitsCompanion.name}",
                               this->impl->${prop.instanceVariableName}.getUnit());
        }
{% end prop.minOccurs == 0 %}\
{% if prop.minOccurs == 0 %}\
        if (this->impl->${prop.instanceVariableName})
          {
            // Attribute property ${prop.name} with units companion ${prop.unitsCompanion.name}
            std::ostringstream os;
            os.imbue(std::locale::classic());
            os << this->impl->${prop.instanceVariableName}->getValue();
            element.setAttribute("${prop.name}", os.str());
            element.setAttribute("${prop.unitsCompanion.name}",
                                 this->impl->${prop.instanceVariableName}->getUnit());
          }
{% end prop.minOccurs == 0 %}\
{% end when %}\
{% when prop.maxOccurs == 1 and prop.isAttribute %}\
        // Attribute property ${prop.name}
        {
          std::ostringstream os;
          os.imbue(std::locale::classic());
{% if prop.minOccurs == 1 %}\
{% if prop.langTypeNS != 'bool' %}\
        os << this->impl->${prop.instanceVariableName};
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
        os << std::boolalpha << this->impl->${prop.instanceVariableName};
{% end %}\
          element.setAttribute("${prop.name}", os.str());
{% end %}\
{% if prop.minOccurs == 0 %}\
          if (this->impl->${prop.instanceVariableName})
            {
{% if prop.langTypeNS != 'bool' %}\
              os << *this->impl->${prop.instanceVariableName};
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
              os << std::boolalpha << *this->impl->${prop.instanceVariableName};
{% end %}\
              element.setAttribute("${prop.name}", os.str());
            }
{% end %}\
        }
{% end %}\
{% when prop.maxOccurs == 1 and prop.isComplex() %}\
        // Element property ${prop.name} which is complex (has
        // sub-elements)
{% if prop.langTypeNS != 'ome::xml::model::primitives::OrderedMultimap' %}\
        if (this->impl->${prop.instanceVariableName})
          {
{% if prop.isAbstractSubstitution %}\
            common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), this->impl->${prop.instanceVariableName}->get${prop.name}Type()));
{% end if %}\
{% if not prop.isAbstractSubstitution %}\
            common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), "${prop.name}"));
{% end if %}\
            this->impl->${prop.instanceVariableName}->asXMLElement(document, child);
            element.appendChild(child);
          }
{% end %}\
{% if prop.langTypeNS == 'ome::xml::model::primitives::OrderedMultimap' %}\
{% if prop.minOccurs == 0 %}\
        if (this->impl->${prop.instanceVariableName})
          {
            common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), "${prop.name}"));
            for (const auto& i : this->impl->${prop.instanceVariableName}->get<0>())
              {
                common::xml::dom::Element pair = document.createElementNS(getXMLNamespace(), "M");
                pair.setAttribute("K", i.first);
                pair.setTextContent(i.second);
                child.appendChild(pair);
              }
            element.appendChild(child);
         }
{% end %}\
{% if prop.minOccurs != 0 %}\
          common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), "${prop.name}"));
          for (const auto& i : this->impl->${prop.instanceVariableName}.get<0>())
            {
              common::xml::dom::Element pair = document.createElementNS(getXMLNamespace(), "M");
              pair.setAttribute("K", i.first);
              pair.setTextContent(i.second);
              child.appendChild(pair);
            }
          element.appendChild(child);
{% end %}\
{% end %}\
{% end %}\
{% when prop.maxOccurs == 1 %}\
        // Element property ${prop.name} which is not complex (has no
        // sub-elements)
        {
{% if prop.minOccurs == 1 %}\
          common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), "${prop.name}"));
          std::ostringstream os;
          os.imbue(std::locale::classic());
{% if prop.langTypeNS != 'bool' %}\
          os << this->impl->${prop.instanceVariableName};
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
          os << std::boolalpha << this->impl->${prop.instanceVariableName};
{% end %}\
          child.setTextContent(os.str());
          element.appendChild(child);
{% end %}\
{% if prop.minOccurs == 0 %}\
          if (this->impl->${prop.instanceVariableName})
            {
              common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), "${prop.name}"));
              std::ostringstream os;
              os.imbue(std::locale::classic());
{% if prop.langTypeNS != 'bool' %}\
              os << *this->impl->${prop.instanceVariableName};
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
              os << std::boolalpha << *this->impl->${prop.instanceVariableName};
{% end %}\
              child.setTextContent(os.str());
              element.appendChild(child);
            }
{% end %}\
        }
{% end %}\
{% when prop.maxOccurs > 1 and prop.isComplex() %}\
        {
          // Element property ${prop.name} which is complex (has
          // sub-elements) and occurs more than once
          for (const auto& i : this->impl->${prop.instanceVariableName})
            {
              if (i)
                {
{% if prop.isAbstractSubstitution %}\
                  common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), i->get${prop.name}Type()));
{% end if %}\
{% if not prop.isAbstractSubstitution %}\
                  common::xml::dom::Element child(document.createElementNS(getXMLNamespace(), "${prop.name}"));
{% end if %}\
                  i->asXMLElement(document, child);
                  element.appendChild(child);
                }
            }
        }
{% end %}\
{% when prop.maxOccurs > 1 %}\
        {
          // Element property ${prop.name} which is not complex (has no
          // sub-elements) which occurs more than once
          for (const auto& i : this->impl->${prop.instanceVariableName})
            {
              common::xml::dom::Element this->impl->${prop.instanceVariableName}_element =
                                                                 document.createElementNS(getXMLNamespace(), "${prop.name}");
              std::ostringstream os;
              os.imbue(std::locale::classic());
{% if prop.langTypeNS != 'bool' %}\
              os << *i;
{% end %}\
{% if prop.langTypeNS == 'bool' %}\
              os << std::boolalpha << i;
{% end %}\
              this->impl->${prop.instanceVariableName}_element.setTextContent(os.str());
              common::xml::dom::Element child(this->impl->${prop.instanceVariableName}_element);
              element.appendChild(child);
            }
        }
{% end %}\
{% otherwise %}\
{% if debug %}\
        // *** WARNING *** Unhandled or skipped property ${prop.name}
{% end debug %}\
{% end %}\
{% end %}\
{% end %}\
{% end for %}\
      }
{% end source %}\

{% if fu.SOURCE_TYPE == "header" %}\
      public:
       // Documented in superclass.
       const std::string&
       getXMLNamespace() const;
{% end header %}\
{% if fu.SOURCE_TYPE == "source" %}\
      const std::string&
      ${klass.name}::getXMLNamespace() const
      {
        static const std::string ns("${klass.namespace}");
        return ns;
      }
{% end source %}\
{% if fu.SOURCE_TYPE == "header" %}\
      };
{% end header %}\

    }
  }
}

{% if fu.SOURCE_TYPE == "header" %}\
#endif // ${fu.GUARD}

/*
 * Local Variables:
 * mode:C++
 * End:
 */
{% end header %}\
